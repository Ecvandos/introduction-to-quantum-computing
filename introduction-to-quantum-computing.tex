\documentclass[11pt, notitlepage]{report}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{epigraph}
\usepackage{chngpage}
\usepackage{fancyhdr}
\usepackage[braket, qm]{qcircuit}
\usepackage[font=small,labelfont=bf, skip=3pt]{caption}
\usepackage[hidelinks]{hyperref}
\usepackage{subcaption}
\usepackage[normalem]{ulem}
\usepackage{tikz}
\usepackage{sectsty}
\usepackage{etoolbox}
\usepackage{titlesec}
\usepackage{dirtytalk}
\usepackage{times}

\titleformat{\chapter}[display]   
{\normalfont\LARGE\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\huge}   
\titlespacing*{\chapter}{0pt}{-50pt}{15pt}

\usepgflibrary{arrows}

%% Gate matrices and quantum state vectors
\newcommand{\igate}{
  \begin{pmatrix}
  1 & 0 \\
  0 & 1
  \end{pmatrix}
}
\newcommand{\xgate}{
  \begin{pmatrix}
  0 & 1 \\
  1 & 0
  \end{pmatrix}
}
\newcommand{\ygate}{
  \begin{pmatrix}
  0 & -i \\
  i & \phantom{-}0
  \end{pmatrix}
}
\newcommand{\zgate}{
  \begin{pmatrix}
  1 & \phantom{-}0 \\
  0 & -1
  \end{pmatrix}
}
\newcommand{\hgate}{
  \dfrac{1}{\sqrt2}
  \begin{pmatrix}
  1 & \phantom{-}1 \\
  1 & -1
  \end{pmatrix}
}
\newcommand{\sgate}{
  \begin{pmatrix}
  1 & 0 \\
  0 & i
  \end{pmatrix}
}
\newcommand{\phasegate}{
  \begin{pmatrix}
  1 & \phantom{e}0 \\
  0 & e^{i\theta}
  \end{pmatrix}
}
\newcommand{\cnotgate}{
  \begin{pmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & 0 & 1 \\
  0 & 0 & 1 & 0 \\
  \end{pmatrix}
}

\newcommand{\qstatezero}{
  \begin{pmatrix}1 \\ 0\end{pmatrix}
}
\newcommand{\qstateone}{
  \begin{pmatrix}0 \\ 1\end{pmatrix}
}

\setlength\epigraphwidth{10cm}
\setlength\epigraphrule{0pt}

\makeatletter
\patchcmd{\epigraph}{\@epitext{#1}}{\itshape\@epitext{#1}}{}{}
\newcommand*{\toccontents}{\@starttoc{toc}}
\makeatother

\renewcommand*{\arraystretch}{1.1}

\pagestyle{fancy}
\lhead{}

\title{\textbf{Introduction to Quantum Computing \\
\large Lectures by Leon Riesebos}}
\author{Steven Oud \\ \emph{soud@pm.me}}
\begin{document}

\vfill
\maketitle

\toccontents

\newpage

\chapter{Fundamentals: A One-Qubit World}
\epigraph{Quantum computers are machines that rely on characteristically quantum phenomena, such as quantum interference and quantum entanglement, in order to perform computation.}{--- Artur Ekert}

\epigraph{It is tempting to say that a quantum computer is one whose operation is governed by the laws of quantum mechanics. But since the laws of quantum mechanics govern the behavior of all physical phenomena, this temptation must be resisted. Your laptop operates under the laws of quantum mechanics, but it is not a quantum computer.}{--- N. David Mermin}

\section{The Qubit}
A quantum bit (\emph{qubit}) - like a classical bit - has a \emph{state}. In classical bits this is 0 or 1. Two possible states for a qubit are \ket{0} and \ket{1} (denoted in \emph{Dirac notation}), which correspond to the states 0 and 1 for a classical bit. The difference between bits and qubits is that a qubit can be in other states than \ket{0} or \ket{1}, often called \emph{superpositions}. The state of a qubit can be denoted as following:
\[\ket{\psi} = \alpha\ket{0} + \beta\ket{1}\]
where $\alpha$ and $\beta$ are complex numbers. The special states \ket{0} and \ket{1} are known as \emph{computational basis states}. We cannot examine a qubit to determine its quantum state. Quantum mechanics tells us we can only acquire much more restricted information about the quantum state. When we measure a qubit we get either 0, with probability $|\alpha|^2$, or 1, with probability $|\beta|^2$. The sum of all probabilities is always equal to 1:
\[|\alpha|^2 + |\beta|^2 = 1\]
For example, a qubit in the state
\[
\dfrac{1}{\sqrt2}\ket{0}+\dfrac{1}{\sqrt2}\ket{1}
\]
gives 0 fifty percent of the time ($|1/\sqrt2|^2$), and 1 fifty percent of the time. This state is often denoted by \ket{+}.

\section{The Bloch Sphere}
The Bloch sphere is a geometrical representation of a qubit's state. It's a spherical coordinate system in which a quantum state can be described as following:
\[
  \ket{\psi} = e^{i\delta} \left(cos\dfrac{\theta}{2}\ket{0} + e^{i\phi}sin\dfrac{\theta}{2}\ket{1}\right)
\]
where $\delta, \theta$ and $\phi$ are real numbers. Factor $e^{i\delta}$ is the global phase of the state. This factor does not influence measurement probabilities, since $\left|e^{i\delta}\right| = 1$. Therefore we can often omit it, allowing us to write
\[
  \ket{\psi} = cos\dfrac{\theta}{2}\ket{0} + e^{i\phi}sin\dfrac{\theta}{2}\ket{1}
\]
The numbers $\theta$ and $\phi$ define a point on the three-dimensional sphere (Figure~\ref{fig:bloch}). The Bloch sphere visualization can be very useful for describing single qubit operations. It is however limited in that there is no simple generalization of the Bloch sphere known for multiple qubits.
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.175]{images/bloch_sphere.eps}
  \vspace{2mm}
  \caption{Bloch sphere representation of a qubit.}
  \label{fig:bloch}
\end{figure}
\par
\newpage

\section{Single-Qubit Quantum Operations}
Single-qubit quantum gates can be seen as rotations on the Bloch sphere. Quantum gates can be represented by matrices, which we will look at in Section~\ref{sec:matrix_notation}. These gates only have one limitation: they have to be \emph{unitary}, that is $U^\dagger U = UU^\dagger = I$, where $U^\dagger$ is the conjugate transpose of $U$ and $I$ the identity operation. Therefore, any $2^n \times 2^n$ unitary matrix is a valid gate which acts on $n$ qubits. Below are some notable single-qubit gates described and visualized.

\subsection{Pauli Gates}\label{pauli_gates}
 The most simple quantum gates are the \emph{Pauli gates} $I$, $X$, $Y$ and $Z$. $I$ is the identity gate, which does nothing. The other gates rotate $\pi$ radians (180 degrees) around the X, Y or Z-axis. These gates are self-inverse, meaning $U^2 = I$.

\begin{figure}[ht]
  \begin{adjustwidth}{-2.5cm}{-2.5cm}
  \centering
  \includegraphics[scale=0.2]{images/pauli_gates.eps}
  \vspace{2mm}
  \caption{Pauli gates $X$, $Y$ and $Z$ visualized on the Bloch sphere.}
  \end{adjustwidth}
\end{figure}

\subsection{Hadamard Gate}
The \emph{Hadamard} ($H$) gate maps the basis states \ket{0} and \ket{1} to superposition states with equal weight. It is the combination of two rotations, $\pi$ radians about the Z-axis followed by $\pi/2$ radians about the Y-axis.

This gate is sometimes described as a ``square root of \textsc{not}" gate, because it turns \ket{0} into $(\ket{0} + \ket{1})/\sqrt2$ (also written as \ket{+}), halfway between \ket{0} and \ket{1}. The Hadamard gate belongs to the Clifford gates.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.18]{images/hadamard_gate.eps}
    \vspace{2mm}
    \caption{Hadamard gate visualized on the Bloch sphere.}
\end{figure}

\subsection{Phase Gates}
Rotation gates that rotate around the Z axis are considered \emph{phase gates}. They rotate the phase of the \ket{1} state by an angle $\theta$ and leave the \ket{0} state unchanged:
\begin{align*}
R_z(\theta) \ket{0} &= \ket{0} \\
R_z(\theta) \ket{1} &= e^{i\theta}\ket{1}
\end{align*}
The probability of measuring a \ket{0} or \ket{1} is unchanged after a phase gate, however it modifies the phase of the quantum state. A common phase gate is the \emph{S gate}, where $\theta = \dfrac{\pi}{2}$ (visualized in Figure \ref{fig:s_bloch}). The Pauli Z gate can be thought of as a phase gate where $\theta = \pi$, because $e^{i\pi} = -1$. Thus you could also think of the $S$ gate as half a Pauli Z gate. Another common phase gate is the \emph{T gate}, where $\theta = \dfrac{\pi}{4}$ (half an $S$ gate).

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.23]{images/s_gate.eps}
  \vspace{2mm}
  \caption{S gate rotation visualized on the Bloch sphere.}
  \label{fig:s_bloch}
\end{figure}

\section{Measurement}
Measuring a qubit collapses its state. The probabilistic result of a qubit measurement can be calculated based on the probability amplitudes:
\[\ket{\psi} = \alpha\ket{0} + \beta\ket{1}\]
\[P(\ket{0}) = \left|\alpha\right|^2\]
\[P(\ket{1}) = \left|\beta\right|^2\]
Consider the following simple single-qubit circuit:

\begin{figure}[ht]
\[
  \Large{
    \Qcircuit @C=1em @R=0em {
    \push{\rule{0em}{1em}} & & \lstick{\ket{0}} & \gate{H} & \gate{Z} & \meter & \cw
    }
  }
\]
\caption{A simple quantum circuit. The output of measuring a qubit is a classical bit, which is distinguished from a qubit by drawing a double-line wire. A visualization of this circuit on the Bloch sphere can be seen in Figure~\ref{fig:gate_rotations}.}
\end{figure}
\noindent
We start with computing $H\ket{0} = \ket{+}$, followed by $Z\ket{+} = \ket{-}$. Finally we measure. We can calculate the probabilities:
\[\ket{-} = \dfrac{1}{\sqrt2} (\ket{0} - \ket{1})\]
\[P(\ket{0}) = \left|\dfrac{1}{\sqrt2}\right|^2 = \dfrac{1}{2}\]
\[P(\ket{1}) = \left|\dfrac{-1}{\sqrt2}\right|^2 = \dfrac{1}{2}\]
Giving us equal probabilities of our state being measured as \ket{0} or \ket{1}.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.37]{images/simple_circuit.eps}
  \vspace{2mm}
  \caption{States of our qubit throughout the circuit from left to right: \ket{0} $\rightarrow$ $H\ket{0}$ $\rightarrow$ $ZH\ket{0}.$}
  \label{fig:gate_rotations}
\end{figure}

\section{Vector Notation} \label{sec:matrix_notation}
Earlier we showed that we can represent a quantum state using the following formula:
\[\ket{\psi} = \alpha\ket{0} + \beta\ket{1}\]
The quantum states $\ket{\psi}$, $\ket{0}$ and $\ket{1}$ in the formula above are vectors. We define $\ket{0}$ and $\ket{1}$ as following:
\[\ket{0} = \qstatezero{}\]
\[\ket{1} = \qstateone{}\]
A quantum state has to be a normalized vector. In general, a qubit's state is a unit vector in a two-dimensional complex vector space. A state can be written out as a linear combination:
\[
  \ket{\psi} = \alpha\qstatezero{} + \beta\qstateone{} =
\begin{pmatrix}\alpha \\ \beta\end{pmatrix}
\]
Single-qubit gates can then be represented by $2 \times 2$ unitary matrices:
\setlength\multicolsep{0pt}
\begin{multicols}{3}
  \[
    I = \igate{}
  \]
  \vfill
  \[
    X = \xgate{}
  \]
  \vfill
  \[
    Y = \ygate{}
  \]
\end{multicols}

\begin{multicols}{3}
  \[
    Z = \zgate{}
  \]
  \vfill
  \[
    S = \sgate{}
  \]
    \vfill
  \[
    H = \hgate{}
  \]
\end{multicols}
\bigskip
\noindent
Then a computation like $X\ket{0}$ can be calculated by matrix vector multiplication:
\[
X\ket{0} = \xgate{} \qstatezero{} = \qstateone{}
\]
And we find that $X\ket{0} = \ket{1}$. Or, more general:
\[
  X\begin{pmatrix}\alpha \\ \beta\end{pmatrix} = \begin{pmatrix}\beta \\ \alpha\end{pmatrix}
\]

You can combine quantum gates by multiplying their matrices. For example, let's verify that $H$ is self-inverse by applying it to itself:
\[
  H^2 = \hgate{} \hgate{} = \igate{} = I
\]
The result is the identity gate, showing that the inverse of $H$ is indeed itself. It is also a \emph{Hermitian matrix}, because it is equal to its own conjugate transpose: $H = H^\dagger$.

\newpage

\chapter{Fundamentals: A Multi-Qubit World}
We can represent multiple qubits using the \emph{Kronecker product} to combine single qubit states:
\[
  \ket{ab} = \ket{a} \otimes \ket{b} = \alpha_{00}\ket{00} + \alpha_{01}\ket{01} + \alpha_{10}\ket{10} + \alpha_{11}\ket{11}
\]
More generally, we say that any linear combination $\sum_{i} \alpha_i\ket{\psi_i}$ is a quantum state with states \ket{\psi_i} and amplitude $\alpha_i$ for state \ket{\psi_i}. To represent \ket{00} for example:
\[
  \ket{00} = \ket{0} \otimes \ket{0} = \qstatezero{} \otimes \qstatezero{} =
  \begin{pmatrix}
  1\qstatezero{} \\[13pt]
  0\qstatezero{}
  \end{pmatrix}
  =
  \begin{pmatrix}
  1 \\
  0 \\
  0 \\
  0
  \end{pmatrix}
\]
Note that the state vector of two qubits is twice as big as the state vector for one qubit. This is where some of the potential power of quantum computers comes from. With $n$ qubits you can represent $2^n$ states - the state space grows exponentially with the number of qubits, unlike classical bits.

For multi-qubit states the rule remains that the state vector has to be normalized. For two qubits for example: $\alpha_{00}\ket{00} + \alpha_{01}\ket{01} + \alpha_{10}\ket{10} + \alpha_{11}\ket{11} = 1$. Or, more general, for a $n$ qubit state:
\[
\sum_{i = 1}^{2^n} |\alpha_i|^2 = 1
\]

\section{Quantum State Evolution}
Doing single-qubit operations on a multi-qubit state is possible by combining the identity and our single-qubit gate. Say we want to compute $H_1\ket{0_0 0_1}$. That is, put the second qubit through a Hadamard gate.\footnote{Note that when I say ``second" qubit, I'm talking about the most right, or least significant qubit. I will number them for this example but assume it from here on out.} To do so, the gate matrix's column width has to be equal to the quantum state vector's dimension. We can achieve this by taking the Kronecker product of the identity matrix and our single-qubit matrix (in this case $H$):
\[
  H_1\ket{0_0 0_1} = (I_0 \otimes H_1)\ket{0_0 0_1}
\]
Writing it out:
\begin{align*}
  I_0 \otimes H_1 &=
  \igate{} \otimes \hgate{} \\
  &=
  \dfrac{1}{\sqrt2}
  \left[
  \igate{}
  \otimes
  \begin{pmatrix}
  1 & \phantom{-}1 \\
  1 & -1
  \end{pmatrix}
  \right] \\
  &= \dfrac{1}{\sqrt2}
  \begin{pmatrix}
  1 & \phantom{-}1 & 0 & \phantom{-}0 \\
  1 & -1 & 0 & \phantom{-}0 \\
  0 & \phantom{-}0 & 1 & \phantom{-}1 \\
  0 & \phantom{-}0 & 1 & -1 \\
  \end{pmatrix}
\end{align*}
Then we can put our \ket{00} state through it:
\[
  \dfrac{1}{\sqrt2}
  \begin{pmatrix}
  1 & \phantom{-}1 & 0 & \phantom{-}0 \\
  1 & -1 & 0 & \phantom{-}0 \\
  0 & \phantom{-}0 & 1 & \phantom{-}1 \\
  0 & \phantom{-}0 & 1 & -1 \\
  \end{pmatrix}
  \begin{pmatrix}
  1 \\
  0 \\
  0 \\
  0
  \end{pmatrix}
  =
  \dfrac{1}{\sqrt2}
  \begin{pmatrix}
  1 \\
  1 \\
  0 \\
  0
  \end{pmatrix}
\]
Which can also be written in Dirac notation as $\dfrac{1}{\sqrt2}(\ket{00} + \ket{01})$.

\section{Partial Measurement}
Say we measure the qubit \ket{q_0} in the following circuit:
\[
  \Large
  \Qcircuit @C=1em @R=0.5em @!R {
    \push{\rule{0em}{1.5em}} & & & \lstick{q_0: \ket{0}} & \gate{H} & \meter & \cw \\
    \push{\rule{0em}{1.5em}} & & & \lstick{q_1: \ket{0}} & \gate{H} & \qw & \qw \\
  }
\]
\noindent
First, we put both qubits in our state \ket{00} through a Hadamard gate. This puts it in the following state:
\[
  (H \otimes H)\ket{00} = \dfrac{1}{2}(\ket{00} + \ket{01} + \ket{10} + \ket{11})
\]
When we measure \ket{q_0} we have a 50/50 probability of getting a 0 or 1. Measuring \ket{q_0} collapses the state to one of the following states:
\[
  \ket{\psi} = 
  \begin{cases}
  \begin{aligned}
    \dfrac{1}{\sqrt2}(\ket{\uline{0}0} + \ket{\uline{0}1}) & \text{ if } M(q_0) = 0 \\
    \dfrac{1}{\sqrt2}(\ket{\uline{1}0} + \ket{\uline{1}1}) & \text{ if } M(q_0) = 1
  \end{aligned}
  \end{cases}
\]
We have two possible states for $q_0$ after measurement: 0 or 1. Qubit \ket{q_1} will stay in superposition because we haven't measured it. Notice how the first qubits (underlined) in both states are the same. This makes sense, we've measured that one so we're certain of its state.

\section{Common Two-Qubit Gates}
\subsection{CNOT Gate}
The quantum gate controlled-\textsc{not} (\textsc{cnot}, sometimes called controlled-$X$) is comparable to a classical computer's \textsc{xor}, but it's reversible. This gate has two input qubits, the \emph{control} qubit and \emph{target} qubit. If the control qubit is set to 0, then the target qubit is left alone. If the control qubit is set to 1, then the target qubit is flipped. The circuit representation for \textsc{cnot} can be seen in Figure~\ref{fig:cnot_circuit}. Qubit $q_0$ represents the control qubit and $q_1$ represents the target qubit. It's essentially a Pauli X gate with a control qubit. \textsc{cnot} is Hermitian and belongs to the Clifford gates.

\begin{figure}[ht]
\centering
\begin{minipage}{.45\textwidth}
  \[
    \Large
    \Qcircuit @C=1em @R=0.5em @!R {
	  \push{\rule{0em}{1em}} & & \lstick{\ket{q_0}} & \ctrl{1} & \qw & \ctrl{1} & \qw \\
	  \push{\rule{0em}{1em}} & & \lstick{\ket{q_1}} & \targ & \qw & \gate{X} & \qw    \\
	}
  \]
  \caption{Two different circuit representations of \textsc{cnot}. We will use the left representation.}
  \label{fig:cnot_circuit}
\end{minipage}%
\hspace*{.05\textwidth}
\begin{minipage}{.45\textwidth}
  \[
    U_{CN} = \cnotgate{}
  \]
  \caption{Matrix representation of \textsc{cnot}.}
\end{minipage}
\end{figure}
\noindent
Let's look at an example of a \textsc{cnot} gate. Consider the following circuit:
\[
  \Large
  \Qcircuit @C=1em @R=0.5em @!R {
    \push{\rule{0em}{1.5em}} & & & \lstick{q_{0}: \ket{0}} & \gate{X}  & \ctrl{1} & \qw & \qw\\
    \push{\rule{0em}{1.5em}} & & & \lstick{q_{1}: \ket{0}} & \qw & \targ & \qw & \qw\\
  }
\]
First we put \ket{q_0} (the control qubit) in the \ket{1} state by applying an $X$ gate, giving us the state \ket{10}. Then we apply the \textsc{cnot} gate:
\[
  \textsc{CNOT}\ket{10} = \cnotgate{}
  \begin{pmatrix}
  0 \\
  0 \\
  1 \\
  0
  \end{pmatrix}
  =
  \begin{pmatrix}
  0 \\
  0 \\
  0 \\
  1
  \end{pmatrix}
  =
  \ket{11}
\]
The target qubit was flipped because the control qubit was set to 1, giving us \ket{11}.

\subsection{CZ Gate}
\textsc{cz}, or the controlled-$Z$ gate, acts in a similar way to other controlled gates. That is, do the operation on the target qubit if the control qubit is set to 1, otherwise do nothing. In \textsc{cz} the operation is the Pauli Z gate. \textsc{cz} is also Hermitian and belongs to the Clifford gates.
\begin{figure}[ht]
\[
  \Large
  \Qcircuit @C=1em @R=0.5em @!R {
    \push{\rule{0em}{1em}} & & \lstick{\ket{q_0}} & \ctrl{1} & \qw & \ctrl{1} & \qw \\
    \push{\rule{0em}{1em}} & & \lstick{\ket{q_1}} & \ctrl{-1} & \qw & \gate{Z} & \qw  \\
  }
\]
\caption{Two different circuit representations of \textsc{CZ}.}
\end{figure}

\subsection{Controlled Gates}
Controlled gates act on two or more qubits, where one or more qubits act as control for some operation. Generally, if $U$ is a gate that operates on single qubits with the following matrix representation:
\[
  U =
  \begin{pmatrix}
  u_{00} & u_{01} \\
  u_{10} & u_{11} \\
  \end{pmatrix}
\]
then the controlled-$U$ gate is a gate that operates on two qubits where the first qubit serves as control. The general matrix representation of the controlled-$U$ then looks as following:
\[
  C(U) =
  \begin{pmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & u_{00} & u_{01} \\
  0 & 0 & u_{10} & u_{11} \\
  \end{pmatrix}
\]
\section{Toffoli Gate}
The Toffoli gate has three inputs and outputs (Figure \ref{fig:toffoli_circuit}), where two of the input qubits act as control bits. The third qubit is the target bit which is flipped if both control qubits are set to 1, otherwise it's left alone. For example, applying the Toffoli gate to the state \ket{110} flips the third qubit, resulting in the state \ket{111}.

\begin{figure}[ht]
\[
  \Large
  \Qcircuit @C=0.54em @R=1em @!R {
    \push{\rule{0em}{1em}} & & & \lstick{a} & \ctrl{1} & \qw & a\\
    \push{\rule{0em}{1em}} & & & \lstick{b} & \ctrl{1} & \qw & b\\
    \push{\rule{0em}{1em}} & & & \lstick{c} & \targ & \qw & & & c \otimes ab\\
  }
\]
\caption{Circuit representation of the Toffoli gate, where $\otimes$ is addition modulo two.}
\label{fig:toffoli_circuit}
\end{figure}
\noindent
The Toffoli, or controlled-controlled-X (\textsc{ccx}) gate can be represented by a $8 \times 8$ matrix:
\[
  U_{CCX} =
  \begin{pmatrix}
  1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
  0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
  0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
  0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
  0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
  0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
  0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
  \end{pmatrix}
\]

\section{Universal Gate Sets}
In classical systems the \textsc{nand} gate is a universal gate, meaning that any other gate can be represented as a combination of \textsc{nand} gates. In quantum computing there exist universal gate sets. A universal gate set requires the full Clifford and Pauli groups, and one or more non-Clifford gates.

We've seen the Pauli gates in Section \ref{pauli_gates}. On their own, Pauli gates have no interesting computational capabilities. The Clifford gates we've seen are $H$, $S$, \textsc{cnot} and \textsc{cz}. Clifford gates introduce the quantum phenomena superposition and entanglement. The Pauli and Clifford gates can be simulated efficiently by classical computers (\emph{Gottesman-Knill theorem}) - showing no increase in efficiency over classical computers.

The non-Clifford gates, which are required for universal quantum computing, cannot be simulated efficiently and are exponentially hard to simulate. Some non-Clifford gates are Toffoli, $T$ and the rotation gates $R_x$, $R_y$ and $R_z$ (which do arbitrary rotations around the axes). One set of universal gates is $\{H,\, T,\, CNOT\}$.

\section{Entanglement}
Two qubits are entangled if and only if the state of those two qubits can \emph{not be expressed as two individual states} (non-separable). Let's first take a look at a separable, or non-entangled state:
\[
  \ket{\psi} = \dfrac{1}{2}(\ket{00} + \ket{01} + \ket{10} + \ket{11})
\]
This state can be separated and expressed as the following two individual states:
\[
  \ket{\psi} = \dfrac{1}{\sqrt2}(\ket{0} + \ket{1}) \otimes \dfrac{1}{\sqrt2}(\ket{0} + \ket{1})
\]
However, consider the following state:
\[
  \ket{\psi} = \dfrac{1}{\sqrt2}(\ket{00} + \ket{11})
\]
This is an entangled state. It cannot be expressed as two individual states. We say two qubits are entangled if they have \emph{nonzero concurrence}. The concurrence of a state can be calculated using the following formula:
\[
  C(\ket{\psi}) = 2|\alpha_{00}\alpha_{11} - \alpha_{01}\alpha_{10}|
\]
We can check if our entangled state is indeed entangled:
\[
  C\left(\dfrac{1}{\sqrt2}(\ket{00} + \ket{11})\right) = 2\left|\dfrac{1}{\sqrt2}\left(\dfrac{1}{\sqrt2}\right)\right| = 1
\]
It has a non-zero concurrence, so we can say it's entangled. How about our non-entangled state?
\[
  C\left(\dfrac{1}{2}(\ket{00} + \ket{01} + \ket{10} + \ket{11})\right) = 2\left|\dfrac{1}{2}\left(\dfrac{1}{2}\right) - \dfrac{1}{2}\left(\dfrac{1}{2}\right)\right| = 0
\]
A concurrence of 0, so it is not entangled.

\section{The Bell States}
The \emph{Bell states} are four maximally entangled quantum states of two qubits:
\begin{align*}
\ket{\Phi^+} = \dfrac{1}{\sqrt2}(\ket{00} + \ket{11}) \\
\ket{\Phi^-} = \dfrac{1}{\sqrt2}(\ket{00} - \ket{11}) \\
\ket{\Psi^+} = \dfrac{1}{\sqrt2}(\ket{01} + \ket{10}) \\
\ket{\Psi^-} = \dfrac{1}{\sqrt2}(\ket{01} - \ket{10})
\end{align*}
We can create a Bell state with the following circuit:
\[
  \Large
  \Qcircuit @C=0.5em @R=0.5em @!R {
    \push{\rule{0em}{1em}} & \ar@{.}[]+<3.25em,0.5em>;[d]+<3.25em,-1em> & & & & & \lstick{q_{0}: \ket{0}} & \qw & \qw & \gate{H} & \qw & \qw \ar@{.}[]+<0.05em,0.5em>;[d]+<0.05em,-1em> & \qw & \ctrl{1} & \qw & \qw & \qw \ar@{.}[]+<-0.7em,0.5em>;[d]+<-0.7em,-1em> \\
    \push{\rule{0em}{1em}} & & & & & & \lstick{q_{1}: \ket{0}} & \qw & \qw & \qw & \qw & \qw & \qw &\targ & \qw & \qw & \qw \\
    & \hspace{6.7em} \ket{\psi_{0}} & \hspace{12.3em} \ket{\psi_{1}} & \hspace{16.4em} \ket{\psi_{2}}
  }
\]
\vspace*{2mm}

\noindent
We start with our state \ket{00} at \ket{\psi_0}. We put \ket{q_0} through a Hadamard gate, giving us the state $\dfrac{1}{\sqrt2}(\ket{00} + \ket{10})$ at \ket{\psi_1}. Finally we \textsc{cnot} that state giving us the final Bell state $\dfrac{1}{\sqrt2}(\ket{00} + \ket{11})$ at \ket{\psi_2}.

The significance of Bell states becomes apparent when we start measuring qubits of a Bell state. Take the circuit we used before to create the Bell state $\dfrac{1}{\sqrt2}(\ket{00} + \ket{11})$ and measure both qubits.
\[
  \Large
  \Qcircuit @C=1em @R=0.5em @!R {
    \push{\rule{0em}{1em}} & & & & \lstick{q_{0}: \ket{0}} & \gate{H} & \ctrl{1} & \meter & \cw  \\
    \push{\rule{0em}{1em}} & & & & \lstick{q_{1}: \ket{0}} & \qw & \targ & \meter & \cw \\
  }
\]
You will find that the measurement results are correlated:
\[
M(q_1) = 0 \text{ if } M(q_0) = 0
\]
\[
M(q_1) = 1 \text{ if } M(q_0) = 1
\]
If you measure $q_0$ to be 0, $q_1$ will also be 0 and vice versa. Note that in our example entangled state they correlate as being equal, but for the entangled state $\dfrac{1}{\sqrt2}(\ket{01} + \ket{10})$ they correlate as being opposites (measuring $q_0$ as 0 means $q_1$ will be 1).

\section{Greenberger-Horne-Zeilinger State}
A Greenberger-Horne-Zeilinger (GHZ) state is a certain type of entangled state. It is a $M > 2$ system state:
\[
\ket{\textsc{GHZ}} = \dfrac{\ket{0}^{\otimes M} + \ket{1}^{\otimes M}}{\sqrt2}
\]
Where $\ket{i}^{\otimes M}$ means the Kronecker product with itself $M$ times. For example $M = 3$:
\[
\ket{\textsc{GHZ}} = \dfrac{\ket{000} + \ket{111}}{\sqrt2}
\]
GHZ states are used for example in cryptography for secret sharing.
\begin{figure}[ht]
\[
  \Large
  \Qcircuit @C=1em @R=0.5em @!R {
  	\push{\rule{0em}{1em}} & & \lstick{\ket{0}} & \gate{H} & \ctrl{1} & \ctrl{2} & \qw  \\
	\push{\rule{0em}{1em}} & & \lstick{\ket{0}} & \qw & \targ & \qw & \qw \\
	\push{\rule{0em}{1em}} & & \lstick{\ket{0}} & \qw & \qw &  \targ & \qw \\
  }
\]
\caption{Circuit creating a three-qubit GHZ state.}
\label{fig:ghz_3}
\end{figure}

\section{Calculating Parity}
Parity checking is one of the simplest forms of error detecting code. It tells us if the number of ones in a set of bits is even or odd. For example, 001 has a parity of 1 (odd) and 110 has a parity of 0 (even). We introduce a quantum algorithm for calculating the parity of an $n$-qubit state. For this example we'll determine the parity of a two-qubit state. Consider the circuit in Figure~\ref{fig:parity_circuit}. We will calculate the parity of \ket{q_0q_1} with \ket{q_2}.
\begin{figure}[ht]
  \[
  \Large
  \Qcircuit @C=1em @R=0.5em @!R {
    \push{\rule{0em}{1em}} & & & \lstick{q_{0}: \ket{0}} & \gate{H} & \ctrl{2} & \qw & \qw & \qw \\
    \push{\rule{0em}{1em}} & & & \lstick{q_{1}: \ket{0}} & \gate{H} & \qw & \ctrl{1} & \qw & \qw \\
    \push{\rule{0em}{1em}} & & & \lstick{q_{2}: \ket{0}} & \qw & \targ &  \targ & \meter & \cw \\
  }
  \]
  \caption{Circuit for calculating parity: $\textsc{CNOT}_{1,2}\textsc{CNOT}_{0,2}H_1H_0\ket{000}$.}
  \label{fig:parity_circuit}
\end{figure}

We start with putting \ket{q_0} and \ket{q_1} in an arbitrary superposition. In this case we apply a Hadamard gate to both qubits, giving us the state
\[
  \ket{\psi} = \dfrac{1}{2}(\ket{000} + \ket{010} + \ket{100} + \ket{110})
\]
Then we apply a $\textsc{cnot}_{0,2}$ operation
\[
  \ket{\psi} = \dfrac{1}{2}(\ket{000} + \ket{010} + \ket{101} + \ket{111})
\]
And a $\textsc{cnot}_{1,2}$, giving us the final state
\[
  \ket{\psi} = \dfrac{1}{2}(\ket{000} + \ket{011} + \ket{101} + \ket{110})
\]
If you look closely at this state, you can see that \ket{q_2} corresponds to the parity of \ket{q_0q_1}. We have essentially calculated the parities of all possible states of \ket{q_0q_1} in parallel. However, we cannot observe a quantum state to extract all the possible states' information. We are limited to measuring one outcome. When we measure \ket{q_2} the state partially collapses leaving only the states with parity $q_2$. Let's take a look at the possible states after measuring \ket{q_2}:
\[
\ket{\psi} = 
\begin{cases}
\begin{aligned}
\dfrac{1}{\sqrt2}(\ket{00} + \ket{11}) \otimes \ket{0} & \text{ if } M(q_2) = 0 \\
\dfrac{1}{\sqrt2}(\ket{01} + \ket{10}) \otimes \ket{1} & \text{ if } M(q_2) = 1
\end{aligned}
\end{cases}
\]
Measuring a 0 leaves us with even parity states and measuring a 1 leaves us with odd parity states. \ket{00} and \ket{11} have even parity ($q_2 = 0$), \ket{01} and \ket{10} have odd parity ($q_2 = 1$).

\section{Quantum Teleportation}
Quantum teleportation it a technique for moving arbitrary quantum states around. It uses an \emph{EPR pair} (a pair of qubits that is in a Bell state) that is shared between the sender and receiver. Note that it is impossible to clone a qubit state. This is referred to as the \emph{no-cloning theorem}. Quantum teleportation works as following: Alice and Bob generate an EPR pair and both take one qubit before they get separated. Alice wants to deliver a qubit \ket{\phi}, whose state is unknown, to Bob. Alice interacts the qubit \ket{\phi} with her half of the EPR pair, and then measures the two qubits in her possession. At this point, Alice's qubits are in one of the four classical states 00, 01, 10 or 11. She sends this information to Bob. Bob then performs one of four operations on his half of the EPR pair, recovering Alice's quantum state \ket{\phi}.

\begin{figure}[ht]
\[
  \Large
  \Qcircuit @C=1em @R=0.5em @!R {
	\push{\rule{0em}{1em}} & & \lstick{q_{0}: \ket{\phi}} \ar@{.}[]+<0.5em,0.5em>;[d]+<0.5em,-3em> & \qw & \qw \ar@{.}[]+<0.9em,0.5em>;[d]+<0.9em,-3em> & \ctrl{1} \ar@{.}[]+<0.9em,0.5em>;[d]+<0.9em,-3em> &\gate{H} \ar@{.}[]+<1.2em,0.5em>;[d]+<1.2em,-3em> & \meter \ar@{.}[]+<1.5em,0.5em>;[d]+<1.5em,-3em> & \cw & \control \cw 
	\ar@{.}[]+<1.2em,0.5em>;[d]+<1.2em,-3em> \\
	\push{\rule{0em}{1em}} & & \lstick{q_{1}: \ket{0}} & \gate{H} & \ctrl{1} & \targ & \qw &\meter & \control \cw & \cwx \\
	\push{\rule{0em}{1em}} & & \lstick{q_{2}: \ket{0}} & \qw & \targ & \qw &\qw & \qw & \gate{X} \cwx & \gate{Z} \cwx &\rstick{\ket{\phi}} \qw \\
	& \hspace{3.3em} \ket{\psi_{0}} & \hspace{9.8em} \ket{\psi_{1}} & \hspace{10em} \ket{\psi_{2}} & \hspace{10.6em} \ket{\psi_{3}} & \hspace{13em} \ket{\psi_{4}} & \hspace{18.2em} \ket{\psi_{5}}
  }
\]
  \vspace{3mm}
  \caption{Quantum circuit teleporting a quantum state \ket{\phi}.}
  \label{fig:teleportation}
\end{figure}
\noindent
The quantum circuit in Figure~\ref{fig:teleportation} teleports the unknown state $\ket{\phi} = \alpha\ket{0} + \beta\ket{1}$. We start at \ket{\psi_0} with the state
\ket{\phi}\ket{00}. Then we create an EPR pair with \ket{q_1q_2}, where \ket{q_1} belongs to Alice and \ket{q_2} to Bob. This gives us the following state at \ket{\psi_1}:
\[
  \ket{\psi_1} = \ket{\phi}\dfrac{1}{\sqrt2}(\ket{00} + \ket{11})
\]
Which we can rewrite as following
\begin{align*}
\ket{\psi_1} &= \alpha\ket{0} + \beta\ket{1} \otimes \dfrac{1}{\sqrt2}(\ket{00} + \ket{11}) \\
&= \dfrac{1}{\sqrt2}\Big(\alpha\ket{0}(\ket{00} + \ket{11}) + \beta\ket{1}(\ket{00} + \ket{11})\Big)
\end{align*}
Alice then sends her qubits through a $\textsc{cnot}_{0, 1}$ gate, obtaining
\[
  \ket{\psi_2} = \dfrac{1}{\sqrt2}\Big(\alpha\ket{0}(\ket{00} + \ket{11}) + \beta\ket{1}(\ket{10} + \ket{01})\Big)
\]
She then sends $q_0$ through a Hadamard gate, giving
\[
  \ket{\psi_3} = \dfrac{1}{2}\Big(\alpha(\ket{0} + \ket{1})(\ket{00} + \ket{11}) + \beta(\ket{0} - \ket{1})(\ket{10} + \ket{01})\Big)
\]
This state can be rewritten in the following way:
\begin{align*}
  \ket{\psi_3} = \dfrac{1}{2}\Big(&\ket{00}(\alpha\ket{0} + \beta{\ket{1}}) \, + \ket{01}(\alpha\ket{1} + \beta\ket{0}) \\
  + \, &\ket{10}(\alpha\ket{0} - \beta\ket{1}) + \ket{11}(\alpha\ket{1} - \beta\ket{0})\Big)
\end{align*}
This expression breaks down in four terms. The first term has Alice's qubits in state \ket{00} and Bob's qubit in state $\alpha\ket{0} + \beta\ket{1}$, which is our original state \ket{\phi}. So in the case that Alice measures $M(q_0q_1) = 00$ at \ket{\psi_4}, Bob's qubit will be in state \ket{\phi}. Depending on Alice's measurement at \ket{\psi_4}, Bob may have to ``fix" his state to recover \ket{\phi} by applying the appropriate gate(s). For example, if Alice measures 00, Bob doesn't have to do anything. If Alice measures 01, Bob can fix his state by applying an $X$ gate. If Alice measures 10, Bob can fix his state by applying a $Z$ gate. And if Alice measures 11, Bob can fix his state by first applying an $X$ gate and then a $Z$ gate. After fixing his state, Bob ends up with Alice's state \ket{\phi} at \ket{\psi_5}.

Note that quantum teleportation does \emph{not} allow for faster than light communication. This is because Bob needs to be told of the result of Alice's measurements through a classical channel in order to complete the teleportation. Also note that we did not clone the quantum state \ket{\phi}, we merely moved it. Teleporting a state depends on the measurement and thus collapsing of the original state \ket{\phi}, so it never allows for cloning.

\chapter{Simple Quantum Algorithms}
Quantum computers promise to solve problems intractable by classical computers. One application is quantum simulation. For example: simulating chemical processes, which are actually quantum processes. As Richard Feynman said: \say{\emph{Nature isn't classical, dammit, and if you want to make a simulation of nature, you'd better make it quantum mechanical.}} Other possible applications include optimization, cryptography and machine learning. There are a lot of efforts in trying to apply quantum computing, but many remain skeptic. We should assume no guarantees in the applications of quantum computers, but continue exploring the possibilities.

When a quantum computer can calculate something efficiently that a classical computer cannot calculate efficiently, we will have reached \emph{quantum supremacy}. The boundary of reaching this is around 50 qubits, when it becomes impossible to simulate a quantum computer. We have not yet reached quantum supremacy, but we are getting close to it. There have been found quantum algorithms which provide a speedup over classical algorithms, like Shor's algorithm for factoring integers and the Deutch-Jozsa algorithm for determining if a boolean function is balanced or unbalanced.

\section{Quantum Arithmetic}
Any classical circuit can be simulated by a quantum circuit. We can show this by creating quantum versions of classical arithmetic functions. One problem with simulating classical gates as quantum gates is that most of them are non-reversible. In quantum computing, it is required for gates to be reversible. This is often solved by adding an output qubit for every input qubit and an extra result qubit (Figure~\ref{fig:add_output_qubit}).
\begin{figure}[ht]
  \[
    \Large
    \Qcircuit @C=1em @R=0.5em {
      \push{\rule{0em}{1em}} & & \lstick{\ket{x}} & \multigate{1}{U_f} & \qw & \ket{x} \\
      \push{\rule{0em}{1em}} & & \lstick{\ket{y}} & \ghost{U_f} & \qw & & \hspace*{5.7mm} \ket{y \otimes f(x)}
    }
  \]
  \caption{Create output qubits for every input qubit in \ket{x} and store the result of $f(x)$ in \ket{y}. $y$ is often assumed to be initialized to 0.}
  \label{fig:add_output_qubit}
\end{figure}
We can create a quantum half adder by creating sum and carry circuits, just like in classical computers. The truth table of the sum function $f_s(x)$ can be found in Figure \ref{fig:sum_truth_table}. We can implement this as a quantum circuit using \textsc{cnot} gates as seen in Figure \ref{fig:sum_quantum_circuit}.

\begin{figure}[ht]
  \begin{minipage}{.45\textwidth}
    \centering
    \begin{tabular}{c|c}
      $x_0$$x_1$ & $f_s(x)$ \\ \hline
      00 & 0 \\
      01 & 1 \\
      10 & 1 \\
      11 & 0 \\
    \end{tabular}
    \caption{Bit sum truth table.}
    \label{fig:sum_truth_table}
  \end{minipage}%
  \hspace*{.05\textwidth}
  \begin{minipage}{.45\textwidth}
    \[
      \Large
      \Qcircuit @C=1em @R=0.5em @!R {
        \push{\rule{0em}{1em}} & & \lstick{\ket{x_{0}}} & \qw & \ctrl{2} & \qw & \qw \\
        \push{\rule{0em}{1em}} & & \lstick{\ket{x_{1}}} & \qw & \qw & \ctrl{1} & \qw \\
        \push{\rule{0em}{1em}} & & \lstick{\ket{y}} & \qw & \targ &  \targ & \qw \\
      }
    \]
    \caption{Quantum circuit for summing two bits using two \textsc{cnot} gates.}
    \label{fig:sum_quantum_circuit}
    \end{minipage}
\end{figure}
\noindent
To fully add two bits we need to account for the carry. The carry function $f_c(x)$ is 1 if and only if both inputs are 1 (Figure~\ref{fig:carry_truth_table}). This truth table corresponds directly to the Toffoli gate (Figure~\ref{fig:carry_quantum_circuit}).

\begin{figure}[ht]
  \begin{minipage}{.45\textwidth}
    \centering
    \begin{tabular}{c|c}
      $x_0$$x_1$ & $f_c(x)$ \\ \hline
      00 & 0 \\
      01 & 0 \\
      10 & 0 \\
      11 & 1 \\
    \end{tabular}
    \caption{Bit carry truth table.}
    \label{fig:carry_truth_table}
  \end{minipage}%
  \hspace*{.05\textwidth}
  \begin{minipage}{.45\textwidth}
    \[
      \Large
      \Qcircuit @C=1em @R=0.5em @!R {
        \push{\rule{0em}{1em}} & & \lstick{\ket{x_{0}}} & \ctrl{2} & \qw \\
        \push{\rule{0em}{1em}} & & \lstick{\ket{x_{1}}} & \ctrl{1} & \qw \\
        \push{\rule{0em}{1em}} & & \lstick{\ket{y}} & \targ & \qw \\
      }
    \]
    \caption{Quantum circuit for taking the carry of two bits implemented using a Toffoli gate.}
    \label{fig:carry_quantum_circuit}
  \end{minipage}
\end{figure}
\noindent
We can combine our sum and carry circuit into one, creating a quantum half adder.

\begin{figure}[ht]
  \[
  \Large
  \Qcircuit @C=1em @R=0.5em @!R {
    \push{\rule{0em}{1em}} & \lstick{\ket{x_0}} & \ctrl{3} & \ctrl{2} & \qw & \qw & \hspace*{2.5mm} \ket{x_0} \\
    \push{\rule{0em}{1em}} & \lstick{\ket{x_1}} & \ctrl{2} & \qw &  \ctrl{1} & \qw & \hspace*{2.5mm} \ket{x_1} \\
    \push{\rule{0em}{1em}} & \lstick{\ket{0}} & \qw & \targ & \targ & \qw & \ket{s} \\
    \push{\rule{0em}{1em}} & \lstick{\ket{0}} & \targ & \qw & \qw & \qw & \ket{c} \\
  }
  \]
  \caption{Quantum half adder. The sum ends up in \ket{s} and the carry in \ket{c}.}
  \label{fig:quantum_full_adder}
\end{figure}
\noindent
Let's check if this circuit works. Say we want to add $\ket{x_0} = \ket{1}$ and $\ket{x_1} = \ket{1}$. We would expect to get 0 as sum and 1 as carry. Our initial state is \ket{1100}. We apply a Toffoli gate, setting the carry qubit to 1: \ket{1101}. Then we set the sum qubit by doing a $\textsc{cnot}_{0,2}$ and a $\textsc{cnot}_{1,2}$ ending up with the state \ket{1101}. Measuring the sum and carry qubits gives $M(s) = 0$ and $M(c) = 1$, giving us what we expected and thus having done a quantum half sum of two qubits.

\section{Deutch-Jozsa Algorithm}
We have shown that we can simulate classical circuits on a quantum computer. This in itself isn't very impressive however, we could already do that on a classical computer. In this section we will describe an algorithm with quantum speedup. Consider the four single-bit operations identity, \textsc{not}, reset and set. 

\begin{figure}[ht]
  \centering
  \begin{multicols}{4}
    \captionof*{table}{\textbf{Identity}\\$f_i(x) = x$}
    \begin{tabular}{c|c}
    $x$ & $f_i(x)$ \\ \hline
    0 & 0 \\
    1 & 1 \\
    \end{tabular}

    \captionof*{table}{\textbf{NOT}\\$f_n(x) = \neg x$}
    \begin{tabular}{c|c}
    $x$ & $f_n(x)$ \\ \hline
    0 & 1 \\
    1 & 0 \\
    \end{tabular}

    \captionof*{table}{\textbf{Reset}\\$f_r(x) = 0$}
    \begin{tabular}{c|c}
    $x$ & $f_r(x)$ \\ \hline
    0 & 0 \\
    1 & 0 \\
    \end{tabular}

    \captionof*{table}{\textbf{Set}\\$f_s(x) = 1$}
    \begin{tabular}{c|c}
    $x$ & $f_s(x)$ \\ \hline
    0 & 1 \\
    1 & 1 \\
   \end{tabular}
  \end{multicols}

  \vspace{4mm}
  \caption{Truth tables for the four single-bit operations.}
  \label{fig:single_bit_operations}
\end{figure}
\noindent
Say we are faced with the following problem: we have a ``black box" with one of the four one-bit functions, but we're not told which one. Determine if the function is \emph{balanced} or \emph{unbalanced}. A balanced function is a function which returns the same amount of 0 and 1s it received as input, like identity and \textsc{not}. Unbalanced functions are functions which return a constant value, like reset and set. This is known as \emph{Deutch's problem} and is one of the first examples of a problem where there exists a quantum algorithm that is exponentially faster than any deterministic classical algorithm.

On a classical computer, to determine if the black box is balanced or unbalanced, we need to do two function calls. On a quantum computer, using the \emph{Deutch-Jozsa} algorithm, we can figure it out using one call to the black box. To use this algorithm for Deutch's problem we need to translate the four single-bit operations to the quantum world. The quantum circuits corresponding to each single-bit operation can be found in Figure~\ref{fig:single_bit_quantum_circuits}.
\vspace{-8mm}
\begin{figure}[ht]
  \centering
  \begin{multicols}{4}
    \[
      \Qcircuit @C=0.7em @R=0.8em @!R {
        \push{\rule{0em}{1em}} & & \lstick{\ket{x}} & \ctrl{1} & \qw \\
        \push{\rule{0em}{1em}} & & \lstick{\ket{y}} & \targ & \qw
      }
    \]
    \caption*{\textbf{Identity}\\$f_i(x) = x$}

    \[
      \Qcircuit @C=0.7em @R=0.5em @!R {
          \push{\rule{0em}{1em}} & & \lstick{\ket{x}} & \gate{X} & \ctrl{1} & \gate{X} & \qw \\
          \push{\rule{0em}{1em}} & & \lstick{\ket{y}} & \qw & \targ & \qw & \qw
      }
    \]
    \caption*{\textbf{NOT}\\$f_n(x) = \neg x$}

    \[
      \Qcircuit @C=0.7em @R=0.8em @!R {
        \push{\rule{0em}{1em}} & & & & & \lstick{\ket{x}} & \qw & \qw & \ghost{X} \\
        \push{\rule{0em}{1em}} & & & & & \lstick{\ket{y}} & \qw & \qw & \ghost{X}
      }
    \]
    \caption*{\textbf{Reset}\\$f_r(x) = 0$}
    
    \[
      \Qcircuit @C=0.7em @R=0.5em @!R {
        \push{\rule{0em}{1em}} & & \lstick{\ket{x}} & \qw & \qw \\
        \push{\rule{0em}{1em}} & & \lstick{\ket{y}} & \gate{X} & \qw
      }
    \]
    \caption*{\textbf{Set}\\$f_s(x) = 1$}
  \end{multicols}

  \vspace{3mm}
  \caption{Quantum circuit representation of the four single-bit operations.}
  \label{fig:single_bit_quantum_circuits}
\end{figure}

\noindent
With these definitions we can start using the Deutch-Jozsa algorithm to efficiently determine what kind of function our black box is. The circuit to do so is described in Figure~\ref{fig:deutch_jozsa_circuit}. In this circuit, $U_f$ refers to our black box function, or as it is sometimes also called, \emph{oracle}.

\begin{figure}[ht]
  \[
    \Large
    \Qcircuit @C=1em @R=1em @!R {
      \push{\rule{0em}{1em}} & & & \lstick{x: \ket{0}} & \gate{H} & \multigate{1}{U_f} & \gate{H} & \meter & \cw \\
      \push{\rule{0em}{1em}} & & & \lstick{y: \ket{1}} & \gate{H} & \ghost{U_f} &  \qw & \qw & \qw
    }
  \]
  \caption{Quantum circuit to determine if $f$ is a balanced or unbalanced function using the Deutch-Jozsa algorithm.}
  \label{fig:deutch_jozsa_circuit}
\end{figure}
\noindent
We can try it out by trying to determine if the identity function $f_i(x) = x$ is balanced or unbalanced. We start with putting \ket{x} and \ket{y} through a Hadamard gate:
\[
  \ket{\psi} = \dfrac{1}{2}(\ket{00} - \ket{01} + \ket{10} - \ket{11})
\]
We evaluate our identity function using $U_f: \ket{x, y \otimes f_i(x)}$:
\[
\ket{\psi} = \dfrac{1}{2}\left(\ket{0, 0 \otimes f_i(0)} - \ket{0, 1 \otimes f_i(0)} + \ket{1, 0 \otimes f_i(1)} - \ket{1, 1 \otimes f_i(1)}\right)
\]
This state contains information about both $f_i(0)$ and $f_i(1)$! We have essentially evaluated two values of $f_i(x)$ simultaneously, a feature known as \emph{quantum parallelism}. Actually applying the function $f_i(x)$, which as we can see in Figure~\ref{fig:single_bit_quantum_circuits} is just a $\textsc{cnot}_{0, 1}$, gives us the following state:
\[
  \ket{\psi} = \dfrac{1}{2}(\ket{00} - \ket{01} + \ket{11} - \ket{10})
\]
And we apply another Hadmard gate on \ket{x}:
\begin{align*}
  \ket{\psi} = \dfrac{1}{2\sqrt2}(&\ket{00} + \ket{10} - \ket{01} - \ket{11} \\
  + \, &\ket{01} - \ket{11} - \ket{00} + \ket{10})
\end{align*}
\vspace*{-10mm}
\begin{align*}
  \phantom{\ket{\psi}} &= \dfrac{1}{2\sqrt2}(\ket{10} + \ket{10} - \ket{11} - \ket{11}) \\
  &= \dfrac{1}{\sqrt2}(\ket{10} - \ket{11})
\end{align*}
We end up with the final state $\dfrac{1}{\sqrt2}(\ket{10} - \ket{11})$ before measurement. We can see from this state that $M(x) = 1$. Curiously, the following measurement outcomes apply:
\begin{align*}
\ket{0_x} \otimes \dfrac{1}{\sqrt2}(\ket{0_y} - \ket{1_y}) & \, \text{ if } \, f(0) = f(1) \\
\ket{1_x} \otimes \dfrac{1}{\sqrt2}(\ket{0_y} - \ket{1_y}) & \, \text{ if } \, f(0) \not= f(1)
\end{align*}
That is, we get $M(x) = 1$ if $f(0) \not= f(1)$, which means $f$ is a balanced function. Likewise, we get $M(x) = 0$ if $f(0) = f(1)$, which means $f$ is an unbalanced function. Since we got a measurement of 1 for $f_i$, and given the fact that the identity operation is balanced, we can say that we effectively determined that $f_i$ is a balanced function with one call to the black box.

% divincenzo criteria
\end{document}
